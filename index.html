<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orderflow — Mobile (FAR Walls + Swing Detector)</title>

  <style>
    :root{
      --bg: #071226;
      --card: #0f2030;
      --muted: #9fb0c8;
      --accent: #00d084;
      --buy: #66ffb2;
      --sell: #ff7b7b;
      --text: #e6f0fb;
      --glass: rgba(255,255,255,0.03);
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, system-ui, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      max-width: 1100px;
      margin: 8px auto;
      padding: 12px;
    }

    header.app-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }

    .title-block h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }

    .subtitle{ font-size:12px; color:var(--muted); margin-top:4px; }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    select,input,button{
      padding:8px 10px;
      border-radius:8px;
      border:0;
      background:#081726;
      color:var(--text);
      font-size:13px;
      outline:none;
    }

    button{ cursor:pointer; box-shadow: 0 6px 14px rgba(0,0,0,0.45); }

    .card{
      background: var(--card);
      padding:12px;
      border-radius:10px;
      margin-top:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }

    .row{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .small{ font-size:12px; color:var(--muted); }
    .big{ font-weight:600; font-size:15px; }

    .top-stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .stat{
      padding:8px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      min-width:120px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:12px;
      margin-top:12px;
    }

    @media (max-width:920px){
      .grid{ grid-template-columns: 1fr; }
      .controls{ width:100%; justify-content:flex-start; }
    }

    .trade-list{
      height:240px;
      overflow:auto;
      padding:6px;
      margin-top:8px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    }

    .trade{ display:flex; justify-content:space-between; padding:6px; border-radius:6px; margin-bottom:4px; font-size:13px; }
    .trade.buy{ color: var(--buy); }
    .trade.sell{ color: var(--sell); }

    .table{ font-size:13px; line-height:1.5; white-space:nowrap; }

    .swing-panel { margin-bottom:12px; min-height:36px; }
    .alertBox{ padding:12px; border-radius:8px; margin-bottom:10px; }
    .swing-high{ background: rgba(255,90,90,0.06); border:1px solid rgba(255,90,90,0.14); color:#ffb3b3; }
    .swing-low{ background: rgba(0,210,130,0.04); border:1px solid rgba(0,210,130,0.12); color:#bfffe0; }

    .logs{ max-height:140px; overflow:auto; font-size:12px; color:var(--muted); margin-top:8px; background:var(--glass); padding:8px; border-radius:8px; }

    .l2-blocks{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px; }
    .l2-col{ max-height:260px; overflow:auto; padding:8px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }

    .controls-right{ display:flex; gap:8px; align-items:center; }

    .muted { color: var(--muted); font-size:12px; }
    .badge { padding:6px 8px; border-radius:8px; background: rgba(255,255,255,0.02); font-size:13px; }

    /* small helpers */
    .small-input{ width:70px; }
    .hidden{ display:none !important; }
    .center { text-align:center; }

    /* scrollbar small */
    ::-webkit-scrollbar{ width:10px; height:8px; }
    ::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.05); border-radius:8px; }

  </style>
</head>
<body>
  <div class="wrap">

    <!-- SWING PANEL (ALWAYS VISIBLE AT TOP) -->
    <div id="swingPanelContainer" class="swing-panel"></div>

    <!-- HEADER -->
    <header class="app-header">
      <div class="title-block">
        <h1>Orderflow — Mobile (Top-10 FAR Walls & Swing)</h1>
        <div class="subtitle">Preload: 20min trades + L2 snapshot · Glitch proxy enabled · Mobile-first</div>
      </div>

      <div class="controls">
        <label class="small muted">Symbol</label>
        <select id="symbolDropdown" aria-label="symbol dropdown">
          <!-- populated dynamically by Part 2 -->
          <option>BTCUSDT</option>
        </select>

        <div class="controls-right">
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" class="hidden">Disconnect</button>
          <span id="status" class="muted">Disconnected</span>
        </div>
      </div>
    </header>

    <!-- TOP STATS -->
    <div class="card">
      <div class="row">
        <div class="top-stats">
          <div class="stat"><div class="small">Preload</div><div id="preloadStatus" class="big">not ready</div></div>
          <div class="stat"><div class="small">Cumulative Delta</div><div id="cumulativeDelta" class="big">0.000000</div></div>
          <div class="stat"><div class="small">Buy / Sell Vol</div><div id="buySellVol" class="big">0 / 0</div></div>
          <div class="stat"><div class="small">Strength</div><div id="strength" class="big">—</div></div>
        </div>

        <div style="text-align:right">
          <div class="muted">Tune</div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
            <label class="small muted">WallSize</label>
            <input id="wallSizeInput" class="small-input" value="200" />
            <label class="small muted">Burst</label>
            <input id="burstInput" class="small-input" value="8" />
          </div>
        </div>
      </div>
    </div>

    <!-- GRID: LEFT (live info) / RIGHT (top walls + controls) -->
    <div class="grid">
      <!-- LEFT -->
      <div>
        <div class="card">
          <div class="small muted">Sweep & Divergence</div>
          <div id="sweepInfo" style="margin-top:8px">—</div>
        </div>

        <div class="card">
          <div class="small muted">Recent Trades (live)</div>
          <div id="tradesList" class="trade-list"></div>
        </div>

        <div class="card">
          <div class="small muted">Logs</div>
          <div id="logs" class="logs"></div>
        </div>
      </div>

      <!-- RIGHT -->
      <div>
        <div class="card">
          <div class="small muted">Top-of-book</div>
          <div style="display:flex;justify-content:space-between;margin-top:8px">
            <div><div class="small muted">Best Bid</div><div id="bestBid" class="big">-</div></div>
            <div><div class="small muted">Best Ask</div><div id="bestAsk" class="big">-</div></div>
          </div>
        </div>

        <div class="card">
          <div class="small muted">FAR Walls (Top-10 each side) — far from current price</div>
          <div style="margin-top:8px">
            <div class="small muted">BUY (farthest)</div>
            <div id="farBuyWalls" class="table" style="min-height:120px"></div>

            <div style="margin-top:10px" class="small muted">SELL (farthest)</div>
            <div id="farSellWalls" class="table" style="min-height:120px"></div>
          </div>
        </div>

        <div class="card">
          <div class="small muted">Controls</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="clearBtn">Clear</button>
            <button id="downloadBtn">Download L2 CSV</button>
          </div>
          <div class="small muted" style="margin-top:8px">Preload: 20 minutes trades + L2 snapshot. Auto reconnect enabled.</div>
        </div>
      </div>
    </div>

    <!-- FULL L2 bottom -->
    <div class="card">
      <div class="small muted">L2 Walls (depth20) — full snapshot (near → far)</div>
      <div class="l2-blocks">
        <div class="l2-col">
          <div class="small muted">BIDS (price — qty)</div>
          <div id="buyWalls" class="table"></div>
        </div>
        <div class="l2-col">
          <div class="small muted">ASKS (price — qty)</div>
          <div id="sellWalls" class="table"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   PART 2 — Symbol Loader + 20-Minute Preload (Trades + L2)
   Uses your Glitch proxy:
   https://binance-cors.glitch.me/?url=
   ============================================================ */

const PROXY = "https://binance-cors.glitch.me/?url=";
const SYMBOLS_ENDPOINT = "https://fapi.binance.com/fapi/v1/exchangeInfo";
const TRADE_HISTORY_ENDPOINT = "https://fapi.binance.com/fapi/v1/aggTrades";
const L2_ENDPOINT = "https://fapi.binance.com/fapi/v1/depth";

const symbolDropdown = document.getElementById("symbolDropdown");
const preloadStatus = document.getElementById("preloadStatus");
const cumulativeDeltaEl = document.getElementById("cumulativeDelta");
const buySellVolEl = document.getElementById("buySellVol");

/* STATE FOR PRELOAD */
let preloadDone = false;
let preloadBuy = 0;
let preloadSell = 0;
let preloadDelta = 0;

/* ============================================================
   LOAD BINANCE SYMBOLS LIST DYNAMICALLY
   ============================================================ */
async function loadSymbols() {
  try {
    document.getElementById("status").innerText = "Loading symbols…";

    const url = PROXY + encodeURIComponent(SYMBOLS_ENDPOINT);
    const res = await fetch(url);
    const json = await res.json();

    if (!json.symbols) {
      console.warn("Symbol list fetch failed", json);
      return;
    }

    symbolDropdown.innerHTML = ""; // clear old

    // Futures USDT pairs only
    const list = json.symbols
      .filter(s => s.quoteAsset === "USDT" && s.contractType === "PERPETUAL")
      .map(s => s.symbol)
      .sort();

    list.forEach(sym => {
      const o = document.createElement("option");
      o.value = sym;
      o.innerText = sym;
      symbolDropdown.appendChild(o);
    });

    document.getElementById("status").innerText = "Symbols loaded";
  }
  catch (err) {
    console.error("Symbol load failed", err);
    document.getElementById("status").innerText = "Symbol load error";
  }
}
loadSymbols();

/* ============================================================
   PRELOAD — 20 MINUTES TRADE HISTORY + L2 SNAPSHOT
   ============================================================ */
async function preload20Minutes(symbol) {
  preloadStatus.innerText = "loading…";
  preloadDone = false;
  preloadBuy = 0;
  preloadSell = 0;
  preloadDelta = 0;

  const endTime = Date.now();
  const startTime = endTime - (20 * 60 * 1000);   // last 20 minutes

  try {
    /* === 1) Load historical trades (aggTrades) === */
    const url = PROXY + encodeURIComponent(
      `${TRADE_HISTORY_ENDPOINT}?symbol=${symbol}&startTime=${startTime}&endTime=${endTime}&limit=1000`
    );

    const res = await fetch(url);
    const trades = await res.json();

    if (Array.isArray(trades)) {
      trades.forEach(t => {
        const qty = parseFloat(t.q);
        const isBuyer = t.m === false; // taker BUY

        if (isBuyer) {
          preloadBuy += qty;
          preloadDelta += qty;
        } else {
          preloadSell += qty;
          preloadDelta -= qty;
        }
      });
    }

    /* === 2) Load L2 snapshot === */
    const l2url = PROXY + encodeURIComponent(
      `${L2_ENDPOINT}?symbol=${symbol}&limit=1000`
    );
    await fetch(l2url); // engine will use live stream anyway

    /* === 3) Update UI === */
    preloadDone = true;
    preloadStatus.innerText = "READY ✓";

    updatePreloadStats();
  }
  catch (err) {
    preloadStatus.innerText = "failed";
    console.error("Preload failed:", err);
  }
}

function updatePreloadStats() {
  cumulativeDeltaEl.innerText = preloadDelta.toFixed(6);
  buySellVolEl.innerText = `${preloadBuy.toFixed(6)} / ${preloadSell.toFixed(6)}`;

  // Strength meter
  const ratio = preloadBuy / Math.max(preloadSell, 1);

  if (ratio > 1.6) strength.innerText = "BUYERS DOMINANT";
  else if (ratio > 1.2) strength.innerText = "Buyers Strong";
  else if (ratio < 0.6) strength.innerText = "Sellers Strong";
  else if (ratio < 0.4) strength.innerText = "SELLERS DOMINANT";
  else strength.innerText = "Balanced";
}

/* ============================================================
   TRIGGER PRELOAD BEFORE CONNECTING
   ============================================================ */

async function startPreloadBeforeConnect() {
  const symbol = symbolDropdown.value;
  console.log("➡ Preload 20 minutes for:", symbol);
  await preload20Minutes(symbol);
  console.log("⬅ Preload complete");
}

/* Expose preload to Part 3 so it waits before opening WS */
window.__PRELOAD_READY = () => preloadDone;
window.__START_PRELOAD = startPreloadBeforeConnect;
window.__GET_PRELOAD_VALUES = () => ({
  buy: preloadBuy,
  sell: preloadSell,
  delta: preloadDelta
});
</script>

<script>
/* ============================================================
   PART 3 — Orderflow Engine + WebSocket + Swing Logic
   ============================================================ */

// ----------------- Configuration -----------------
const WS_RECONNECT_MS = 3000;
const MAX_TRADES_DISPLAY = 100;
const BURST_WINDOW_MS = 2500;
const PRELOAD_WAIT_TIMEOUT = 8000; // ms to wait for preload before connecting anyway
const FAR_WALL_COUNT = 5; // number of far walls to show per side

// ----------------- State -----------------
let ws = null;
let running = false;
let symbolEl = document.getElementById('symbolDropdown') || document.getElementById('symbol');
let symbol = symbolEl ? symbolEl.value.toLowerCase() : 'btcusdt';

let buyVol = 0, sellVol = 0, cumDelta = 0;
let recentTrades = []; // {price, qty, side, ts}
let bids = [], asks = [];
let lastBestBid = null, lastBestAsk = null;
let lastHigh = null, lastLow = null;
let lastPrice = null, lastPrice2 = null;
let lastDeltaSide = null;
let lastOrderbookSnapshot = null;
let calibrated = false;
let calibrationStartedAt = null;

const statusEl = document.getElementById('status') || { innerText: '' };
const connectBtn = document.getElementById('connectBtn') || { addEventListener:()=>{} };
const disconnectBtn = document.getElementById('disconnectBtn') || { addEventListener:()=>{} };
const tradesEl = document.getElementById('tradesList');
const topBidsEl = document.getElementById('topBids');
const topAsksEl = document.getElementById('topAsks');
const buyWallsEl = document.getElementById('buyWalls');
const sellWallsEl = document.getElementById('sellWalls');
const bestBidEl = document.getElementById('bestBid');
const bestAskEl = document.getElementById('bestAsk');
const buyClusterEl = document.getElementById('buyCluster');
const sellClusterEl = document.getElementById('sellCluster');
const volsEl = document.getElementById('vols');
const cumlEl = document.getElementById('cumulativeDelta');
const strengthEl = document.getElementById('strength');
const swingPanelContainer = document.getElementById('swingPanelContainer');
const sweepInfoEl = document.getElementById('sweepInfo');
const divergenceInfoEl = document.getElementById('divergenceInfo');
const buyBurstEl = document.getElementById('buyBurst');
const sellBurstEl = document.getElementById('sellBurst');
const aggrEl = document.getElementById('aggr');
const logsEl = document.getElementById('logs');
const calibEl = document.getElementById('calib');
const preloadStatusEl = document.getElementById('preloadStatus') || { innerText: '' };
const farBuyEl = document.getElementById('farBuyWalls') || null;
const farSellEl = document.getElementById('farSellWalls') || null;

// If Part 2 used different ids, tolerant fallback
const symbolDropdown = document.getElementById('symbolDropdown') || symbolEl;

// simple helpers
const f = v => (v === undefined || v === null) ? 0 : parseFloat(v);
const now = () => Date.now();
function log(msg){ if(!logsEl) return; const d = document.createElement('div'); d.innerText = `[${(new Date()).toLocaleTimeString()}] ${msg}`; logsEl.prepend(d); if(logsEl.childElementCount>200) logsEl.removeChild(logsEl.lastChild); }

// ----------------- UI update throttling -----------------
let uiTimer = null;
function scheduleUI(){ if(uiTimer) return; uiTimer = setTimeout(()=>{ uiTimer = null; updateUI(); }, 120); }

function updateUI(){
  // volumes
  volsEl && (volsEl.innerText = `${buyVol.toFixed(6)} / ${sellVol.toFixed(6)}`);
  cumlEl && (cumlEl.innerText = cumDelta.toFixed(6));

  // best bid/ask
  const bidsByPrice = bids.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
  const asksByPrice = asks.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
  bestBidEl && (bestBidEl.innerText = bidsByPrice.length ? bidsByPrice[0][0] : '-');
  bestAskEl && (bestAskEl.innerText = asksByPrice.length ? asksByPrice[0][0] : '-');

  // top walls
  const topB = bidsByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const topA = asksByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  topBidsEl && (topBidsEl.innerHTML = topB.map(it=>`${it[0]} — ${it[1]}`).join('<br>'));
  topAsksEl && (topAsksEl.innerHTML = topA.map(it=>`${it[0]} — ${it[1]}`).join('<br>'));
  buyWallsEl && (buyWallsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>'));
  sellWallsEl && (sellWallsEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>'));

  // clusters
  const wallSizeInput = document.getElementById('wallSizeInput');
  const wallSize = wallSizeInput ? (parseFloat(wallSizeInput.value) || 50) : 50;
  const buyClusterCount = topB.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = topA.filter(it=>it[1] > wallSize).length;
  buyClusterEl && (buyClusterEl.innerText = String(buyClusterCount));
  sellClusterEl && (sellClusterEl.innerText = String(sellClusterCount));

  // bursts
  const windowStart = now() - BURST_WINDOW_MS;
  const recentWindowTrades = recentTrades.filter(r=>r.ts >= windowStart);
  const buyAgg = recentWindowTrades.filter(r=>r.side==='buy').length;
  const sellAgg = recentWindowTrades.filter(r=>r.side==='sell').length;
  buyBurstEl && (buyBurstEl.innerText = String(buyAgg));
  sellBurstEl && (sellBurstEl.innerText = String(sellAgg));
  aggrEl && (aggrEl.innerText = (buyAgg>sellAgg)?'BUY':(sellAgg>buyAgg)?'SELL':'—');

  // strength
  const ratio = buyVol / Math.max(sellVol, 1);
  if(ratio > 1.6) strengthEl && (strengthEl.innerText = 'BUYERS DOMINANT');
  else if(ratio > 1.2) strengthEl && (strengthEl.innerText = 'Buyers Strong');
  else if(ratio < 0.6) strengthEl && (strengthEl.innerText = 'Sellers Strong');
  else if(ratio < 0.4) strengthEl && (strengthEl.innerText = 'SELLERS DOMINANT');
  else strengthEl && (strengthEl.innerText = 'Balanced');

  // far walls
  renderFarWalls();
}

// ----------------- Far-wall detection -----------------
function getFarWalls(bidsArr, asksArr, count=FAR_WALL_COUNT){
  // We want "distance" walls, not the immediate near book.
  // Compute mid price and sort by qty, but prefer ones that are farther from mid.
  const mid = (() => {
    const bb = bidsArr[0] ? f(bidsArr[0][0]) : null;
    const ba = asksArr[0] ? f(asksArr[0][0]) : null;
    if(bb && ba) return (bb + ba) / 2;
    return bb || ba || 0;
  })();

  // annotate with distance score
  const annotate = (entry) => {
    const p = f(entry[0]);
    const q = f(entry[1]);
    const dist = Math.abs(p - mid) / Math.max(1, mid);
    return { price: p, qty: q, dist };
  };

  const annotatedBids = bidsArr.map(annotate).filter(x=>x.qty>0);
  const annotatedAsks = asksArr.map(annotate).filter(x=>x.qty>0);

  // prefer large qty and larger distance; use combined score
  annotatedBids.forEach(a=>a.score = a.qty * (1 + a.dist * 8));
  annotatedAsks.forEach(a=>a.score = a.qty * (1 + a.dist * 8));

  const farBids = annotatedBids.sort((a,b)=>b.score - a.score).slice(0, count);
  const farAsks = annotatedAsks.sort((a,b)=>b.score - a.score).slice(0, count);

  return { mid, farBids, farAsks };
}

function renderFarWalls(){
  if(!farBuyEl || !farSellEl) return;
  const { farBids, farAsks } = getFarWalls(bids, asks, FAR_WALL_COUNT);

  // display far walls in top-right cluster area
  const farBHtml = farBids.map(x => `${x.price} — ${x.qty}`).join('<br>');
  const farAHtml = farAsks.map(x => `${x.price} — ${x.qty}`).join('<br>');

  farBuyEl.innerHTML = farBHtml;
  farSellEl.innerHTML = farAHtml;
}

// ----------------- Swing detection engine -----------------

function wallShiftDetected(oldOb, newOb){
  if(!oldOb || !newOb) return false;
  const oldBestBidQty = oldOb.bids[0]?.[1] ?? 0;
  const newBestBidQty = newOb.bids[0]?.[1] ?? 0;
  const oldBestAskQty = oldOb.asks[0]?.[1] ?? 0;
  const newBestAskQty = newOb.asks[0]?.[1] ?? 0;
  return (newBestBidQty > oldBestBidQty * 1.4) || (newBestAskQty > oldBestAskQty * 1.4);
}

function fastReaction(price){
  if(!lastPrice || !lastPrice2) return false;
  return Math.abs(price - lastPrice2) > (Math.abs(lastPrice - lastPrice2) * 1.5);
}

function rateSwingFlags(flags){
  const stars = flags.filter(v => v === true).length;
  return '★'.repeat(stars) + '☆'.repeat(5 - stars);
}

function showSwingPanel(type, price, flags){
  const colorClass = type === 'HIGH' ? 'swing-high' : 'swing-low';
  const title = type === 'HIGH' ? 'SWING HIGH' : 'SWING LOW';
  const stars = rateSwingFlags(flags);
  const html = `
    <div class="alertBox ${colorClass}">
      <strong style="font-size:15px">${title} @ ${price}</strong><br><br>
      • Liquidity Sweep: <b>${flags.sweep ? 'YES' : 'NO'}</b><br>
      • Delta Flip: <b>${flags.deltaFlip ? 'YES' : 'NO'}</b><br>
      • Momentum: <b>${flags.momentum ? 'YES' : 'NO'}</b><br>
      • Wall Shift: <b>${flags.wallShift ? 'YES' : 'NO'}</b><br>
      • Reaction Speed: <b>${flags.reactionSpeed ? 'YES' : 'NO'}</b><br>
      <hr>
      <b>Swing Rating: ${stars}</b>
    </div>
  `;
  swingPanelContainer && (swingPanelContainer.innerHTML = html + swingPanelContainer.innerHTML);
  log(`${title} @ ${price} | rating ${stars}`);
}

// core detection — called from trade handler
function detectSwing(price, delta){
  const deltaSide = delta > 0 ? 'buy' : 'sell';
  const deltaFlipToBuy = (lastDeltaSide === 'sell' && deltaSide === 'buy');
  const deltaFlipToSell = (lastDeltaSide === 'buy' && deltaSide === 'sell');

  const sweepHigh = (lastHigh !== null) && (price > lastHigh);
  const sweepLow  = (lastLow !== null) && (price < lastLow);

  const momentum = Math.abs(delta) > 20; // tuneable
  const wallShift = wallShiftDetected(lastOrderbookSnapshot, lastOrderbookSnapshot); // simple placeholder; updated in depth handler
  const reaction = fastReaction(price);

  const flags = {
    sweep: sweepHigh || sweepLow,
    deltaFlip: deltaFlipToBuy || deltaFlipToSell,
    momentum: momentum,
    wallShift: wallShift,
    reactionSpeed: reaction
  };

  // Fire only when both mandatory matched:
  if(sweepHigh && deltaFlipToSell) showSwingPanel('HIGH', price, flags);
  if(sweepLow && deltaFlipToBuy) showSwingPanel('LOW', price, flags);

  // update memory
  lastDeltaSide = deltaSide;
  if(lastHigh === null || price > lastHigh) lastHigh = price;
  if(lastLow === null || price < lastLow) lastLow = price;
}

// ----------------- Handle depth snapshot -----------------
function handleDepthPayload(payload){
  // unify to bids/asks arrays of [price, qty]
  if(payload.b) bids = payload.b.slice();
  if(payload.a) asks = payload.a.slice();

  // update snapshot
  lastOrderbookSnapshot = { bids: bids.slice(), asks: asks.slice() };

  // track bests & extremes
  const bestB = bids.length ? f(bids[0][0]) : null;
  const bestA = asks.length ? f(asks[0][0]) : null;
  if(bestB !== null){
    if(lastBestBid !== null && bestB < lastBestBid) log(`BestBid collapsed ${lastBestBid} → ${bestB}`);
    lastBestBid = bestB;
    if(lastLow === null || bestB < lastLow) lastLow = bestB;
  }
  if(bestA !== null){
    if(lastBestAsk !== null && bestA > lastBestAsk) log(`BestAsk expanded ${lastBestAsk} → ${bestA}`);
    lastBestAsk = bestA;
    if(lastHigh === null || bestA > lastHigh) lastHigh = bestA;
  }

  scheduleUI();
}

// ----------------- Handle trade payload -----------------
function handleTradePayload(t){
  const price = f(t.p || t.price || t.P);
  const qty = f(t.q || t.qty || t.Q || t.quantity) || f(t.q || t.size);
  // Binance aggTrade has boolean m (isMaker)
  const isMaker = (t.m === true);
  // m=true => trade executed by maker (taker was seller) → sell trade
  const side = isMaker ? 'sell' : 'buy';
  const ts = now();

  // record
  recentTrades.unshift({price, qty, side, ts});
  if(recentTrades.length > 2000) recentTrades.pop();

  // update vol/delta (persist initial preloaded values if any)
  if(side === 'buy'){ buyVol += qty; cumDelta += qty; }
  else { sellVol += qty; cumDelta -= qty; }

  // price memory
  lastPrice2 = lastPrice;
  lastPrice = price;

  // display trade
  if(tradesEl){
    const el = document.createElement('div');
    el.className = 'trade ' + (side==='buy'?'buy':'sell');
    el.innerHTML = `<div>${side.toUpperCase()} <span style="opacity:0.7">${price}</span></div><div>${qty}</div>`;
    tradesEl.prepend(el);
    if(tradesEl.childElementCount > MAX_TRADES_DISPLAY) tradesEl.removeChild(tradesEl.lastChild);
  }

  // run lightweight detectors
  detectSwing(price, cumDelta);
  scheduleUI();
}

// ----------------- Connect / Reconnect -----------------
function buildStreamUrl(sym){
  // sym like btcusdt -> stream as btcusdt@trade/btcusdt@depth20@100ms
  const s = sym.toLowerCase();
  return `wss://fstream.binance.com/stream?streams=${s}@trade/${s}@depth20@100ms`;
}

async function startConnection(sym){
  if(running) return;
  symbol = sym.toLowerCase();

  // Wait for preload if available (Part2) but not longer than timeout
  const start = now();
  if(window.__START_PRELOAD) {
    try { window.__START_PRELOAD(); } catch(e) { /* ignore */ }
  }
  // wait until preloadReady or timeout
  while(now() - start < PRELOAD_WAIT_TIMEOUT){
    if(typeof window.__PRELOAD_READY === 'function' && window.__PRELOAD_READY()) break;
    await new Promise(r=>setTimeout(r, 150));
  }
  // initialize with preloaded values if provided
  if(typeof window.__GET_PRELOAD_VALUES === 'function'){
    const pv = window.__GET_PRELOAD_VALUES();
    if(pv){
      buyVol = (pv.buy || 0);
      sellVol = (pv.sell || 0);
      cumDelta = (pv.delta || 0);
      scheduleUI();
      log('Initialized from preload: ' + `buy:${buyVol}, sell:${sellVol}, delta:${cumDelta}`);
    }
  }

  const url = buildStreamUrl(symbol);
  statusEl && (statusEl.innerText = 'Connecting…');

  try {
    ws = new WebSocket(url);
  } catch(e){
    log('WebSocket create failed: ' + e.message);
    setTimeout(()=> startConnection(symbol), WS_RECONNECT_MS);
    return;
  }

  ws.onopen = () => {
    running = true;
    statusEl && (statusEl.innerText = 'Connected');
    connectBtn && (connectBtn.style.display = 'none');
    disconnectBtn && (disconnectBtn.style.display = 'inline-block');
    log('WS open to ' + symbol);
    startCalibration();
  };

  ws.onmessage = (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      // Binance stream wrapper: { stream: "...", data: {...} }
      const payload = msg.data || msg;
      if(!payload) return;
      // trade event
      // trade event type fields: e:'trade', p:price, q:qty, m:isMaker
      if(payload.e === 'trade' || payload.e === 'aggTrade' || payload.p){
        handleTradePayload(payload);
        return;
      }
      // depth event: payload.b (bids pair), payload.a (asks pair)
      if(payload.b || payload.a){
        handleDepthPayload(payload);
        return;
      }
      // sometimes nested arrays
      if(Array.isArray(payload.b) || Array.isArray(payload.a)){
        handleDepthPayload(payload);
        return;
      }
    } catch(err){
      // sometimes message isn't JSON or unexpected schema
      // console.warn('parse err', err);
    }
  };

  ws.onclose = () => {
    running = false;
    statusEl && (statusEl.innerText = 'Disconnected');
    connectBtn && (connectBtn.style.display = 'inline-block');
    disconnectBtn && (disconnectBtn.style.display = 'none');
    log('WS closed — reconnecting in ' + (WS_RECONNECT_MS/1000) + 's');
    stopCalibration();
    setTimeout(()=> startConnection(symbol), WS_RECONNECT_MS);
  };

  ws.onerror = (e) => {
    statusEl && (statusEl.innerText = 'WS error');
    log('WS error');
    // will trigger onclose -> reconnect
  };
}

function stopConnection(){
  if(ws) try { ws.close(); } catch(e){}
  ws = null;
  running = false;
  statusEl && (statusEl.innerText = 'Disconnected');
  connectBtn && (connectBtn.style.display = 'inline-block');
  disconnectBtn && (disconnectBtn.style.display = 'none');
  stopCalibration();
}

// ----------------- Calibration -----------------
const CALIBRATION_SECONDS = 180;
function startCalibration(){
  calibrationStartedAt = now();
  calibrated = false;
  calibEl && (calibEl.innerText = `Calibrating… ${CALIBRATION_SECONDS}s`);
  const interval = setInterval(()=>{
    if(!calibrationStartedAt){ clearInterval(interval); return; }
    const elapsed = Math.floor((now() - calibrationStartedAt) / 1000);
    const remaining = CALIBRATION_SECONDS - elapsed;
    if(remaining <= 0){
      calibrated = true;
      calibEl && (calibEl.innerText = 'READY ✓');
      clearInterval(interval);
      log('Calibration complete — engine ready');
    } else {
      calibEl && (calibEl.innerText = `Calibrating… ${remaining}s`);
    }
  }, 800);
}
function stopCalibration(){ calibrationStartedAt = null; calibEl && (calibEl.innerText = 'Not running'); calibrated = false; }

// ----------------- Clear / Download -----------------
function clearAll(){
  buyVol = 0; sellVol = 0; cumDelta = 0;
  recentTrades = []; bids = []; asks = [];
  lastBestBid = null; lastBestAsk = null; lastHigh = null; lastLow = null;
  lastPrice = null; lastPrice2 = null; lastDeltaSide = null; lastOrderbookSnapshot = null;
  calibrated = false; calibrationStartedAt = null;
  swingPanelContainer && (swingPanelContainer.innerHTML = '');
  logsEl && (logsEl.innerHTML = '');
  updateUI();
  log('State cleared');
}

function downloadL2CSV(){
  const rows = ['side,price,qty'];
  bids.forEach(b=>rows.push(`bid,${b[0]},${b[1]}`));
  asks.forEach(a=>rows.push(`ask,${a[0]},${a[1]}`));
  const blob = new Blob([rows.join('\n')], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${symbol}_l2_snapshot.csv`; a.click(); URL.revokeObjectURL(url);
}

// ----------------- UI wiring -----------------
if(connectBtn) connectBtn.addEventListener('click', async () => {
  const sym = (symbolDropdown && symbolDropdown.value) ? symbolDropdown.value.trim().toLowerCase() : (symbol || 'btcusdt');
  // start preload (part2 will do it)
  if(typeof window.__START_PRELOAD === 'function') {
    try { window.__START_PRELOAD(); } catch(e) {}
  }
  await startConnection(sym);
});

if(disconnectBtn) disconnectBtn.addEventListener('click', ()=> stopConnection());

const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');
if(clearBtn) clearBtn.addEventListener('click', clearAll);
if(downloadBtn) downloadBtn.addEventListener('click', downloadL2CSV);

// symbol dropdown change should update symbol variable
if(symbolDropdown) symbolDropdown.addEventListener('change', (e) => {
  symbol = e.target.value.toLowerCase();
  // update displayed symbol in status and optionally restart connection
  statusEl && (statusEl.innerText = `Selected ${symbol.toUpperCase()}`);
});

// startup: if the page already had a symbol and user wants auto-connect, do nothing — wait for click
updateUI();
log('Part 3 loaded — attach Connect to begin.');

/* Expose for debugging */
window.__of_engine = {
  startConnection, stopConnection, clearAll, downloadL2CSV, getState: () => ({buyVol, sellVol, cumDelta, bidsLen: bids.length, asksLen: asks.length})
};
</script>

</body>
</html>
